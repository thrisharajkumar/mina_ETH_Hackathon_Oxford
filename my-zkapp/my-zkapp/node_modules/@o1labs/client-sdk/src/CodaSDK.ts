/* TypeScript file generated from CodaSDK.re by genType. */
/* eslint-disable import/first */


// @ts-ignore: Implicit any on import
const CodaSDKBS = require('./CodaSDK.bs');

import type {uint32 as $$uint32} from './TSTypes';

import type {uint64 as $$uint64} from './TSTypes';

// tslint:disable-next-line:interface-over-type-literal
export type publicKey = string;

// tslint:disable-next-line:interface-over-type-literal
export type privateKey = string;

// tslint:disable-next-line:interface-over-type-literal
export type uint64 = $$uint64;

// tslint:disable-next-line:interface-over-type-literal
export type uint32 = $$uint32;

// tslint:disable-next-line:interface-over-type-literal
export type keypair = { readonly privateKey: privateKey; readonly publicKey: publicKey };

// tslint:disable-next-line:interface-over-type-literal
export type signature = { readonly field: string; readonly scalar: string };

// tslint:disable-next-line:interface-over-type-literal
export type signed<signable> = {
  readonly publicKey: publicKey; 
  readonly signature: signature; 
  readonly payload: signable
};

// tslint:disable-next-line:interface-over-type-literal
export type stakeDelegation = {
  readonly to: publicKey; 
  readonly from: publicKey; 
  readonly fee: uint64; 
  readonly nonce: uint32; 
  readonly memo?: string; 
  readonly validUntil?: uint32
};

// tslint:disable-next-line:interface-over-type-literal
export type payment = {
  readonly to: publicKey; 
  readonly from: publicKey; 
  readonly fee: uint64; 
  readonly amount: uint64; 
  readonly nonce: uint32; 
  readonly memo?: string; 
  readonly validUntil?: uint32
};

/** 
  * Generates a public/private keypair
  */
export const genKeys: () => keypair = CodaSDKBS.genKeys;

/** 
  * Derives the public key of the corresponding private key
  *
  * @param privateKey - The private key used to get the corresponding public key
  * @returns A public key
  */
export const derivePublicKey: (privateKey:privateKey) => publicKey = CodaSDKBS.derivePublicKey;

/** 
  * Verifies if a keypair is valid by checking if the public key can be derived from
  * the private key and additionally checking if we can use the private key to
  * sign a transaction. If the keypair is invalid, an exception is thrown.
  *
  * @param keypair - A keypair
  * @returns True if the `keypair` is a verifiable keypair, otherwise throw an exception
   */
export const verifyKeypair: (keypair:keypair) => boolean = CodaSDKBS.verifyKeypair;

/** 
  * Signs an arbitrary message
  *
  * @param key - The keypair used to sign the message
  * @param message - An arbitrary string message to be signed
  * @returns A signed message
  */
export const signMessage: (_1:string, _2:keypair) => signed<string> = CodaSDKBS.signMessage;

/** 
  * Verifies that a signature matches a message.
  *
  * @param signedMessage - A signed message
  * @returns True if the `signedMessage` contains a valid signature matching
  * the message and publicKey.
  */
export const verifyMessage: (_1:signed<string>) => boolean = CodaSDKBS.verifyMessage;

/** 
  * Signs a payment transaction using a private key.
  *
  * This type of transaction allows a user to transfer funds from one account
  * to another over the network.
  *
  * @param payment - An object describing the payment
  * @param key - The keypair used to sign the transaction
  * @returns A signed payment transaction
  */
export const signPayment: (_1:payment, _2:keypair) => signed<payment> = CodaSDKBS.signPayment;

/** 
  * Signs a stake delegation transaction using a private key.
  *
  * This type of transaction allows a user to delegate their
  * funds from one account to another for use in staking. The
  * account that is delegated to is then considered as having these
  * funds when determining whether it can produce a block in a given slot.
  *
  * @param stakeDelegation - An object describing the stake delegation
  * @param key - The keypair used to sign the transaction
  * @returns A signed stake delegation
  */
export const signStakeDelegation: (_1:stakeDelegation, _2:keypair) => signed<stakeDelegation> = CodaSDKBS.signStakeDelegation;

/** 
  * Verifies a signed payment.
  *
  * @param signedPayment - A signed payment transaction
  * @returns True if the `signed(payment)` is a verifiable payment
   */
export const verifyPaymentSignature: (signedPayment:signed<payment>) => boolean = CodaSDKBS.verifyPaymentSignature;

/** 
  * Verifies a signed stake delegation.
  *
  * @param signedStakeDelegation - A signed stake delegation
  * @returns True if the `signed(stakeDelegation)` is a verifiable stake delegation
   */
export const verifyStakeDelegationSignature: (signedStakeDelegation:signed<stakeDelegation>) => boolean = CodaSDKBS.verifyStakeDelegationSignature;

/** 
  * Converts a Rosetta signed transaction to a JSON string that is
  * compatible with GraphQL. The JSON string is a representation of
  * a `Signed_command` which is what our GraphQL expects.
  *
  * @param signedRosettaTxn - A signed Rosetta transaction
  * @returns A string that represents the JSON conversion of a signed Rosetta transaction`.
   */
export const signedRosettaTransactionToSignedCommand: (signedRosettaTxn:string) => string = CodaSDKBS.signedRosettaTransactionToSignedCommand;
